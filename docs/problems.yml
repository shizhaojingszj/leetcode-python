problems:
  lt79:
    name: 79. Word Search
    description: |
      Given an m x n grid of characters board and a string word, return true if word exists in the grid.

      The word can be constructed from letters of sequentially adjacent cells, where adjacent cells are horizontally or vertically neighboring. The same letter cell may not be used more than once.

    solution:
      - 一个grid，每个位置都可以考虑，每个位置都有4个方向，所以是DFS
      - 有限制，说走过的cell不能再走，所以是backtracking有条件要回复
      - recursive有两个参数重要，word和index
      - recursive写的时候，self.dfs是一个predicate
      - found是四个方向成功条件的any
    
  lt1041:
    name: 1041. Robot Bounded In Circle
    description: |
      On an infinite plane, a robot initially stands at (0, 0) and faces north. Note that:

      The north direction is the positive direction of the y-axis.
      The south direction is the negative direction of the y-axis.
      The east direction is the positive direction of the x-axis.
      The west direction is the negative direction of the x-axis.
      The robot can receive one of three instructions:

      "G": go straight 1 unit.
      "L": turn 90 degrees to the left (i.e., anti-clockwise direction).
      "R": turn 90 degrees to the right (i.e., clockwise direction).
      The robot performs the instructions given in order, and repeats them forever.

      Return true if and only if there exists a circle in the plane such that the robot never leaves the circle.

    solution:
      - 结束的条件是：回到原点 or 最终方向跟起始不同
      - 使用(0,0)表示原点，每个G表示一个坐标变化

  lt424:
    name: 424. Longest Repeating Character Replacement
    description: |
      You are given a string s and an integer k. You can choose any character of the string and change it to any other uppercase English character. You can perform this operation at most k times.

      Return the length of the longest substring containing the same letter you can get after performing the above operations.

    solution:
      - 快慢指针，指针间为滑动窗口，滑动窗口统计最大的char是哪个
      - 条件：比较最大的char出现次数n + k >= window的大小，此时符合要求，可以算答案

  lt337:
    name: 337. House Robber III
    description: |
      The thief has found himself a new place for his thievery again. There is only one entrance to this area, called root.

      Besides the root, each house has one and only one parent house. After a tour, the smart thief realized that all houses in this place form a binary tree. It will automatically contact the police if two directly-linked houses were broken into on the same night.

      Given the root of the binary tree, return the maximum amount of money the thief can rob without alerting the police.

    solution:
      - 二叉树，贪心算法
      - 条件是不允许出现parent和direct child同时被rob的情况
      - 主函数需要考虑[rob, not_rob]两种情况，返回一个列表
      - 在parent被rob的时候，只能返回direct children分别被not_rob的情况
      - 在parent考虑not_rob的情况，需要考虑每个child的两种情况：max([rob, not_rob])

  lt365:
    name: 365. Water and Jug Problem
    description: |

      You are given two jugs with capacities jug1Capacity and jug2Capacity liters. There is an infinite amount of water supply available. Determine whether it is possible to measure exactly targetCapacity liters using these two jugs.

      If targetCapacity liters of water are measurable, you must have targetCapacity liters of water contained within one or both buckets by the end.

      Operations allowed:

      Fill any of the jugs with water.
      Empty any of the jugs.
      Pour water from one jug into another till the other jug is completely full, or the first jug itself is empty.

    solution:
      - 问题很实际，是两个烧杯称出一个实际的值
      - 使用DFS吧，数学法想不到啊
      - 不过gcd应该会
      - DFS的下一步操作，需要只考虑容量大的烧杯，否则可能会因为节点太多，过不了
      - 停止的条件：作为可行步骤的stack里面没有新的步骤了，因为步骤（大烧杯量）都见过了
      - DFS2(from Michelle)以只考虑大的烧杯为例（也就是每次状态小烧杯要么满，要么空），需要考虑的有：
        - 找到的条件：
          - 大烧杯目前量等于目标
          - 大烧杯总量等于目标
          - 小烧杯总量等于目标
          - 小烧杯总量与大烧杯目前量等于目标
        - 上述条件未找到，那么大烧杯下一个目前量可能的操作：
          - 大烧杯目前量 + 小烧杯总量 (state + x)
          - 大烧杯目前量 - 小烧杯总量 (state - x)
          - 大烧杯目前量先给小烧杯，小烧杯存着；之后再把大烧杯填满，再往小烧杯倒直到把小烧杯倒满；此时，大烧杯新的目前量 (y - (x - state) )
          - 大烧杯可能快满了，利用小烧杯：小烧杯总量倒给大烧杯直到满；然后将小烧杯剩余量给到大烧杯。 (x - (y - state) )
